<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Giải mã AUTOSAR | bbtd</title>
<meta name=keywords content="software"><meta name=description content="Kiến trúc tiêu chuẩn ngành Automotive"><meta name=author content="Dung"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.7b595f5b6ea26149d115dfe78d071bc5ed145620b4177d3b53cc2b115b05027b.css integrity="sha256-e1lfW26iYUnRFd/njQcbxe0UViC0F307U8wrEVsFAns=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://du4ng.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://du4ng.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://du4ng.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://du4ng.github.io/apple-touch-icon.png><link rel=mask-icon href=https://du4ng.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://du4ng.github.io/posts/autosar/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F9VS7QYQ27"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F9VS7QYQ27")</script><meta property="og:title" content="Giải mã AUTOSAR"><meta property="og:description" content="Kiến trúc tiêu chuẩn ngành Automotive"><meta property="og:type" content="article"><meta property="og:url" content="https://du4ng.github.io/posts/autosar/"><meta property="og:image" content="https://mayfest.viblo.asia/_nuxt/img/eb0fecb.svg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-06T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-06T00:00:00+00:00"><meta property="og:site_name" content="Dung"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mayfest.viblo.asia/_nuxt/img/eb0fecb.svg"><meta name=twitter:title content="Giải mã AUTOSAR"><meta name=twitter:description content="Kiến trúc tiêu chuẩn ngành Automotive"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://du4ng.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Giải mã AUTOSAR","item":"https://du4ng.github.io/posts/autosar/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Giải mã AUTOSAR","name":"Giải mã AUTOSAR","description":"Kiến trúc tiêu chuẩn ngành Automotive","keywords":["software"],"articleBody":"​\nGiới thiệu ​ AUTOSAR có vẻ khá xa lạ đối với người làm về công nghệ thông tin, nhưng đối với những bạn làm về Embedded System, đặc biệt là trong lĩnh vực Automotive, thì cũng… xa lạ nốt.\nDạo một vòng trên Google, mình thấy tài liệu về AUTOSAR bằng tiếng Anh rất chi là hàn lâm, còn tiếng Việt thì hầu như không có. Theo dòng sự kiện MayFest2023, mình muốn chia sẻ chút kiến thức ít ỏi mà mình nghe lén được khi vẫn còn ăn bám ở công ty.\nAUTOSAR (AUTomotive Open System ARchitecture) là một kiến trúc phần mềm được tiêu chuẩn hóa dùng để thiết kế ECU trong ngành công nghiệp Automotive. Nhưng, tiêu chuẩn là tiêu chuẩn gì, tiêu chuẩn hóa như thế nào và tiêu chuẩn đó nằm ở đâu trên một chiếc ô tô ?\nLấy ví dụ đơn giản - trường học. Cứ đến cuối kỳ, sinh viên có hàng tá môn phải thi, mỗi môn lại là một giảng viên khác nhau. Để nộp bài cho giảng viên thì có rất nhiều kênh: Zalo, Gmail, LMS,… tương tự cho việc giảng viên phải dạy rất nhiều lớp. Điều này khiến việc liên lạc giữa hai bên dễ gây confused, không chỉ vào lúc thi mà còn trong quá trình học tập. Vậy, solution cho việc này là gì ? Thi tập trung ! Sinh viên chẳng cần phải nhớ xem sẽ nộp bài cho ông thầy nào và nộp qua đâu, chỉ việc xách đít đi thi rồi về chờ điểm trên trang online, nhà trường sẽ lo việc còn lại.\nCái mình muốn nói ở đây, đó là giữa sinh viên và nhà trường luôn có sự thống nhất về một mặt nào đó, có thể là qua hình thức, qua format đề thi, hoặc qua kỳ sau học lại.\nTrở lại, đối với lĩnh vực Automotive, sự phức tạp của software trên ô tô ngày càng cao là một trong những lý do chính cho sự ra đời AUTOSAR. Do đó, thứ mà chúng ta cần chính là sự thống nhất trong thiết kế giữa bên mua, bên bán, giữa phần cứng, phần mềm và ti tỉ thứ khác nữa. Cụ thể hơn, mình có một flow giao dịch đơn giản trông như thế này: ㅤ Supplier ➔ OEM ➔ End-user Hmm, vậy người mua xe nằm ở đâu trong flow trên ? Họ chính là những End-users, tức “người dùng cuối” trong flow này. Vậy OEM (Original Equipment Manufacturers) ở đây là ai ? Chính là các hãng xe: Volkswagen, BWM, Peugeot, v.v.. có đủ. Những ông lớn này tất nhiên sẽ không làm ra một chiếc xe hẳn hoi mà chỉ tập trung vào sản xuất thứ mà họ giỏi nhất, sau đó mua những component lặt vặt khác, chẳng hạn như hệ thống sensor từ một bên chỉ chuyên sản xuất sensor, trong trường hợp này là ECU. Các hãng xe phần lớn sẽ không tự thiết kế ECU mà phải nhờ đến một bên thứ ba, tức Supplier như Bosch, Hitachi, Continental,…\nMọi người thấy đấy, OEM đâu chỉ mua mỗi ECU mà còn mua linh ta linh tinh. OEM thì mua rất nhiều thịt từ những Suppliers khác nhau, Supplier thì bán rất nhiều cá cho những OEMs khác nhau. Đã thế, xe thì đâu chỉ có mỗi xe xăng, còn có xe điện, xe hybrid,… Nhưng dù cho có là xe gắn phản lực, xe bay, xe tàng hình đi chăng nữa, AUTOSAR vẫn cân tất, bởi lẽ như mình đã nói, nó được sinh ra cũng bởi sự bộn bề của software mà 😵‍💫.\nDưới đây là thứ tự các tầng bên trong kiến trúc AUTOSAR từ cao xuống thấp:\nApplication Layer Runtime Environment Basic Software Services Layer ECU Abstraction Layer Microcontroller Abstraction Layer Complex Drivers Microcontroller ah shiet 🤓 Big brain time !!! ​\n1. Application Software (ASW) Là tầng cao nhất trong kiến trúc AUTOSAR, cũng là thằng “gần” nhất với người dùng. Gần ở đây nghĩa là những thứ ta có thể tương tác trực tiếp, chẳng hạn như đèn báo trên tablo, hệ thống phanh, khí thải, điều hòa, đồng hồ đo nhiên liệu, vòng tua, hay cả màn hình cảm ứng ở những xe đời mới.\nNhưng đó chỉ là bề nổi của ASW, trái tim thật sự của tầng này được gọi là các SWCs (Software Components). Từng chức năng riêng biệt trên xe sẽ được đảm nhận bởi một component riêng. Mình sẽ gọi mỗi component này là một “cục”.\nVí dụ, trên ô tô dĩ nhiên có máy lạnh, nhưng máy lạnh sẽ không hoạt động một mình. Đằng sau nó là cả một hệ thống ventilation, được kiểm soát bởi một SWC, mình tạm gọi là cục thông gió, có chức năng kiểm soát lượng không khí ra vào cabin. Hoặc, một SWC khác là cục khí thải, dựa vào sensor để collect data về các thành phần trong lượng khí thải hiện tại như NOx, CO, HC,… từ đó điều chỉnh các tham số để timing cho việc mix nhiên liệu với không khí. Thực tế, việc này còn đòi hỏi sự kết hợp giữa nhiều SWCs như cục điều khiển động cơ phun, cục monitoring và diagnostic. Thậm chí, các nhà sản xuất còn có thể dùng những cục có chức năng quan sát (monitoring, diagnostic,…) để bắt bệnh sau một thời gian xe được dùng và cải tiến software/hardware trong những đời sau.\n​\n⚠️Tẹo mình sẽ nói về anh bạn Runtime Environment (RTE) sau. RTE đóng vai trò như cầu nối giúp hai khứa ASW và BSW tâm sự với nhau. Mà muốn biết tâm sự kiểu gì trước hết phải biết BSW hoạt động ra sao đã. ​\n2. Basic Software (BSW) Là tầng thấp nhất của software, và cũng là tầng khó nhai nhất 🤕.\nBSW được chia ra thành những sub-layers, mỗi sub-layer cung cấp từng service nhất định cho các SWCs ở tầng ASW.\n2.1. Service Layer Là thằng gần nhất với ASW, thật ra RTE gần hơn nhưng mình không coi RTE là hẳn một tầng 🤫. Service Layer chịu trách nhiệm chính trong việc giúp BSW cung cấp các service lên trên ASW nhờ vào API (API thì tầng nào cũng có nhé).\nVí dụ:\nLoại API Chức năng Communication Giao tiếp trong network của các ECU, gửi message qua CAN, LIN, FlexRay,… Diagnostic Chuẩn đoán lỗi, dùng để đọc DTC (Diagnostic Trouble Codes). Time Management Kiểm soát các cyclic task, trên ô tô có vô số giá trị phải đọc trong lúc xe chạy như tốc độ, nhiệt độ,… Memory Management Tương tự Time Management nhưng là kiểm soát bộ nhớ dùng cho các cyclic task. Và còn rất nhiều loại khác như API cho Event Management, File System hoặc Security.\n2.2 ECU Abstraction Layer (EAL) Sub-layer này và cả sub-layer bên dưới của BSW sẽ hơi lằng nhằng bởi chúng đều mang tính “trừu tượng”.\nTrừu tượng ở đây cũng giống như tính chất trừu tượng bên OOP, đều mang mục đích giấu đi độ phức tạp của các implementation, giúp dev viết code một cách chuẩn hóa hơn và đỡ trầm cảm hơn.\nCụ thể, khi dev viết code ở sub-layer này, họ không phải căng mắt tìm cho ra địa chỉ của thanh ghi ADCs, ngắt, timer,… mà chỉ việc lụm API, truy cập vào tài nguyên của hardware thông qua ngoại vi, rồi config theo requirement. Mình từng thắc mắc, làm sao API có thể compatible với các hardware khác nhau ứng với mỗi con ECU khác nhau trên từng dòng xe khác nhau ? Welp, như đã nói, mọi thứ đều đã được chuẩn hóa, hardware được chuẩn hóa, software được chuẩn hóa, và API cũng vậy.\nAbstraction cũng là một key principle của AUTOSAR. Như mình đã đề cập từ đầu, có rất nhiều OEMs và Suppliers trong cuộc chơi này, nghĩa là có cả trăm loại software và hardware sắp sửa đánh nhau. Nhưng nhờ vào Abstraction, software từ một Supplier có thể dễ dàng được “tái sử dụng” khi switch sang hardware platform của một OEM khác và ngược lại.\nNói tóm lại, ngoài abstract giữa phần mềm với phần mềm như mọi người thường thấy, còn có cả abstract giữa phần mềm và phần cứng 🥴.\n3.2 Microcontroller Abstraction Layer (MCAL) Đây là thằng cuối cùng còn sót lại trong mớ software, nằm ngay trên hardware.\nThằng này thì cũng không có gì phức tạp, cơ bản là ở gần hardware nên nguyên lý khá giống với compiler. Khác ở chỗ, compiler gen ra .bin, .hex hay .obj gì đó một lần để flash xuống rồi thôi, còn MCAL cho phép high-level với low-level code nói chuyện với nhau trong real-time.\nTưởng tượng như này, ECU Abstraction Layer (EAL) chính là “bộ não”, trong khi Microcontroller Abstraction Layer (MCAL) đóng vai trò như một “hệ thần kinh”. EAL gửi đi các high-level command, còn MCAL biến các command đó thành low-level, rồi mới đi vào ECU. EAL ngồi trên đầu trên cổ thằng MCAL, giống như một bộ não, gửi tín hiệu qua hệ thần kinh để các cơ bắp hay nội tạng hoạt động theo ý muốn. Trong trường hợp này, EAL nếu muốn sử dụng tài nguyên của hardware thì phải nhờ vả MCAL.\n3.4 Complex Device Drivers (CDDs) Nhập gia tùy… tiện, chúng ta có một impostor ở đây. Không phải cứ nằm trong kiến trúc nào là phải mang hẳn quy tắc của kiến trúc đó. Sẽ có những trường hợp chúng ta cần tốc độ xử lý ở mức cao nhất, do đó phải bỏ qua tối đa các macro để code thẳng vào logic, tránh function call quá nhiều gây tăng instruction trong quá trình runtime. Ví dụ như việc bung túi khí, đòi hỏi tốc độ response cực kì cao.\nDo đó nếu mọi người để ý, ta sẽ thấy ngoại lệ khi MCU được nối thẳng lên tầng trên qua CDD, cắt bớt layer để giảm time. ​\n4. Runtime Environment (RTE) Đây giồi đôi giầy, cùng quay lại với người anh em thiện lành RTE.\nRTE thật ra là một term chung chứ không chỉ của riêng ngành nhúng, và là một environment có liên quan mật thiết đến “system”.\nMình chưa có cơ hội làm nhiều với system nên cũng không dám nói nhăng nói cuội. Mentor của mình đã giải thích về nó 800 lần nhưng mình vẫn không hiểu. Btw, mình từng đọc một tài liệu nói về RTE như sau:\nRTE là lớp phần mềm trung gian giúp hai tầng ASW và BSW giao tiếp với nhau. Mục đích của việc này là làm cho các thành phần phần mềm độc lập nhất có thể để “ánh xạ” tới một hệ thống điều khiển.\nYep, đúng là không hiểu thật.\nCơ mà, “ánh xạ” là gì nhỉ ? Mình chỉ nghĩ đơn giản thế này, sở dĩ RTE tồn tại là vì AUTOSAR muốn đảm bảo ASW và BSW độc lập với nhau nhất có thể. BSW không chỉ trừu tượng hóa giữa các sub-layers bên trong mình mà còn giữa chính bản thân nó với ASW.\nGiả dụ:\nASW sẽ được dev 100% bởi OEM để điều khiển các function trên xe. BSW sẽ được dev bởi Supplier để cung cấp các service cơ bản nhất cho ASW lụm về dùng. Trên thực tế con số 100% này ở tầng ASW có thể khác, OEM có thể chỉ dev 75%, 50% hoặc quẳng hết cho Supplier làm luôn tùy thuộc vào thỏa thuận hai bên. Vì lý do bảo mật công nghệ, phần trăm càng cao nghĩa là OEM càng không muốn tiết lộ công nghệ của họ 🙄 mình cho là vậy.\nDễ thấy hai khứa ASW và BSW hợp tác rất đơn giản, chỉ việc đưa và nhận, đổi lại là sự flexibility trong kiến trúc mỗi thằng. Và “ánh xạ”, một lần nữa, cũng là cách mà abstraction hoạt động, kết nối hai thằng này với nhau, dịch sang tiếng người nghĩa là “mapping”.\nNhưng map là map cái gì ? Vâng, chính là SWCs. Đơn giản, quá trình mapping chỉ định SWC nào sẽ được map đến ECU nào, chẳng hạn cụm ABS, cụm cửa sổ, cụm túi khí,…\nLớp RTE trong dự án thực tế được macro cực kì nhiều cũng bởi đặc trưng của AUTOSAR. Có đến vài chục file .c và .h bắt đầu bằng Rte như Rte.c, Rte.h, Rte_Lib.h, Rte_Type.h,…\n​\n5. Microcontroller (MCU) Updating\n​\n","wordCount":"2118","inLanguage":"en","image":"https://mayfest.viblo.asia/_nuxt/img/eb0fecb.svg","datePublished":"2023-05-06T00:00:00Z","dateModified":"2023-05-06T00:00:00Z","author":{"@type":"Person","name":"Dung"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://du4ng.github.io/posts/autosar/"},"publisher":{"@type":"Organization","name":"bbtd","logo":{"@type":"ImageObject","url":"https://du4ng.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://du4ng.github.io/ accesskey=h title="Dung (Alt + H)"><img src=https://du4ng.github.io/apple-touch-icon.png alt aria-label=logo height=35>Dung</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://du4ng.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://beacons.ai/livin/room title=Vault><span>Vault</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Giải mã AUTOSAR</h1><div class=post-description>Kiến trúc tiêu chuẩn ngành Automotive</div><div class=post-meta><span title='2023-05-06 00:00:00 +0000 UTC'>May 6, 2023</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Dung&nbsp;|&nbsp;<a href=https://viblo.asia/p/giai-ma-autosar-kien-truc-de-doi-nganh-automotive-phan-1-EoW4ox6zJml rel="noopener noreferrer" target=_blank>Xem tại VIBLO</a></div></header><figure class=entry-cover><img loading=lazy src=https://mayfest.viblo.asia/_nuxt/img/eb0fecb.svg alt><p></p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#giới-thiệu>Giới thiệu</a></li><li><a href=#1-application-software-asw>1. Application Software (ASW)</a></li><li><a href=#2-basic-software-bsw>2. Basic Software (BSW)</a><ul><li><a href=#21-service-layer>2.1. Service Layer</a></li><li><a href=#22-ecu-abstraction-layer-eal>2.2 ECU Abstraction Layer (EAL)</a></li><li><a href=#32-microcontroller-abstraction-layer-mcal>3.2 Microcontroller Abstraction Layer (MCAL)</a></li><li><a href=#34-complex-device-drivers-cdds>3.4 Complex Device Drivers (CDDs)</a></li></ul></li><li><a href=#4-runtime-environment-rte>4. Runtime Environment (RTE)</a></li><li><a href=#5-microcontroller-mcu>5. Microcontroller (MCU)</a></li></ul></nav></div></details></div><div class=post-content><p>​</p><h2 id=giới-thiệu>Giới thiệu<a hidden class=anchor aria-hidden=true href=#giới-thiệu>#</a></h2><p>​
AUTOSAR có vẻ khá xa lạ đối với người làm về công nghệ thông tin, nhưng đối với những bạn làm về Embedded System, đặc biệt là trong lĩnh vực Automotive, thì cũng&mldr; xa lạ nốt.</p><p>Dạo một vòng trên Google, mình thấy tài liệu về AUTOSAR bằng tiếng Anh rất chi là hàn lâm, còn tiếng Việt thì hầu như không có. Theo dòng sự kiện <strong>MayFest2023</strong>, mình muốn chia sẻ chút kiến thức ít ỏi mà mình nghe lén được khi vẫn còn ăn bám ở công ty.</p><p><img loading=lazy src=meme.png alt="Baby with his first word"></p><p><strong>AUTOSAR</strong> (<strong>AUT</strong>omotive <strong>O</strong>pen <strong>S</strong>ystem <strong>AR</strong>chitecture) là một kiến trúc phần mềm được tiêu chuẩn hóa dùng để thiết kế ECU trong ngành công nghiệp Automotive. Nhưng, tiêu chuẩn là tiêu chuẩn gì, tiêu chuẩn hóa như thế nào và tiêu chuẩn đó nằm ở đâu trên một chiếc ô tô ?</p><p>Lấy ví dụ đơn giản - trường học. Cứ đến cuối kỳ, sinh viên có hàng tá môn phải thi, mỗi môn lại là một giảng viên khác nhau. Để nộp bài cho giảng viên thì có rất nhiều kênh: Zalo, Gmail, LMS,&mldr; tương tự cho việc giảng viên phải dạy rất nhiều lớp. Điều này khiến việc liên lạc giữa hai bên dễ gây confused, không chỉ vào lúc thi mà còn trong quá trình học tập. Vậy, solution cho việc này là gì ? Thi tập trung ! Sinh viên chẳng cần phải nhớ xem sẽ nộp bài cho ông thầy nào và nộp qua đâu, chỉ việc xách đít đi thi rồi về chờ điểm trên trang online, nhà trường sẽ lo việc còn lại.</p><p>Cái mình muốn nói ở đây, đó là giữa sinh viên và nhà trường luôn có sự <strong>thống nhất</strong> về một mặt nào đó, có thể là qua hình thức, qua format đề thi, hoặc qua kỳ sau học lại.</p><p>Trở lại, đối với lĩnh vực Automotive, sự phức tạp của software trên ô tô ngày càng cao là một trong những lý do chính cho sự ra đời AUTOSAR. Do đó, thứ mà chúng ta cần chính là sự <strong>thống nhất</strong> trong thiết kế giữa bên mua, bên bán, giữa phần cứng, phần mềm và ti tỉ thứ khác nữa. Cụ thể hơn, mình có một flow giao dịch đơn giản trông như thế này:<br><br><br>ㅤ Supplier ➔ OEM ➔ End-user<br><br><br>Hmm, vậy người mua xe nằm ở đâu trong flow trên ? Họ chính là những <strong>End-users</strong>, tức &ldquo;người dùng cuối&rdquo; trong flow này. Vậy <strong>OEM (Original Equipment Manufacturers)</strong> ở đây là ai ? Chính là các hãng xe: Volkswagen, BWM, Peugeot, v.v.. có đủ. Những ông lớn này tất nhiên sẽ không làm ra một chiếc xe hẳn hoi mà chỉ tập trung vào sản xuất thứ mà họ giỏi nhất, sau đó mua những component lặt vặt khác, chẳng hạn như hệ thống sensor từ một bên chỉ chuyên sản xuất sensor, trong trường hợp này là ECU. Các hãng xe phần lớn sẽ không tự thiết kế ECU mà phải nhờ đến một bên thứ ba, tức <strong>Supplier</strong> như Bosch, Hitachi, Continental,&mldr;</p><p>Mọi người thấy đấy, OEM đâu chỉ mua mỗi ECU mà còn mua linh ta linh tinh. OEM thì mua rất nhiều thịt từ những Suppliers khác nhau, Supplier thì bán rất nhiều cá cho những OEMs khác nhau. Đã thế, xe thì đâu chỉ có mỗi xe xăng, còn có xe điện, xe hybrid,&mldr; Nhưng dù cho có là xe gắn phản lực, xe bay, xe tàng hình đi chăng nữa, AUTOSAR vẫn cân tất, bởi lẽ như mình đã nói, nó được sinh ra cũng bởi sự bộn bề của software mà 😵‍💫.</p><p>Dưới đây là thứ tự các tầng bên trong kiến trúc AUTOSAR từ cao xuống thấp:</p><p><img loading=lazy src=https://images.viblo.asia/e6a569fb-6539-49e0-8cde-187527574b1f.png alt></p><ul><li><strong>Application Layer</strong></li><li><strong>Runtime Environment</strong></li><li><strong>Basic Software</strong><ul><li>Services Layer</li><li>ECU Abstraction Layer</li><li>Microcontroller Abstraction Layer</li><li>Complex Drivers</li></ul></li><li><strong>Microcontroller</strong></li></ul><p><br><br><br>ah shiet 🤓 Big brain time !!!<br><br>​</p><h2 id=1-application-software-asw>1. Application Software (ASW)<a hidden class=anchor aria-hidden=true href=#1-application-software-asw>#</a></h2><p><img loading=lazy src=ASW.png alt="Application Software Layer"></p><p>Là tầng cao nhất trong kiến trúc AUTOSAR, cũng là thằng &ldquo;gần&rdquo; nhất với người dùng. Gần ở đây nghĩa là những thứ ta có thể tương tác trực tiếp, chẳng hạn như đèn báo trên tablo, hệ thống phanh, khí thải, điều hòa, đồng hồ đo nhiên liệu, vòng tua, hay cả màn hình cảm ứng ở những xe đời mới.</p><p>Nhưng đó chỉ là bề nổi của ASW, trái tim thật sự của tầng này được gọi là các <strong>SWCs</strong> (Software Components). Từng chức năng riêng biệt trên xe sẽ được đảm nhận bởi một component riêng. Mình sẽ gọi mỗi component này là một &ldquo;cục&rdquo;.</p><p>Ví dụ, trên ô tô dĩ nhiên có máy lạnh, nhưng máy lạnh sẽ không hoạt động một mình. Đằng sau nó là cả một hệ thống ventilation, được kiểm soát bởi một SWC, mình tạm gọi là cục thông gió, có chức năng kiểm soát lượng không khí ra vào cabin. Hoặc, một SWC khác là cục khí thải, dựa vào sensor để collect data về các thành phần trong lượng khí thải hiện tại như NOx, CO, HC,&mldr; từ đó điều chỉnh các tham số để timing cho việc mix nhiên liệu với không khí. Thực tế, việc này còn đòi hỏi sự kết hợp giữa nhiều SWCs như cục điều khiển động cơ phun, cục monitoring và diagnostic. Thậm chí, các nhà sản xuất còn có thể dùng những cục có chức năng quan sát (monitoring, diagnostic,&mldr;) để bắt bệnh sau một thời gian xe được dùng và cải tiến software/hardware trong những đời sau.</p><p><br>​</p><table><thead><tr><th>⚠️Tẹo mình sẽ nói về anh bạn <strong>Runtime Environment (RTE)</strong> sau. RTE đóng vai trò như cầu nối giúp hai khứa ASW và BSW tâm sự với nhau. Mà muốn biết tâm sự kiểu gì trước hết phải biết BSW hoạt động ra sao đã.</th></tr></thead><tbody></tbody></table><p><br>​</p><h2 id=2-basic-software-bsw>2. Basic Software (BSW)<a hidden class=anchor aria-hidden=true href=#2-basic-software-bsw>#</a></h2><p><img loading=lazy src=BSW.png alt="Basic Software Layer"></p><p>Là tầng thấp nhất của software, và cũng là tầng khó nhai nhất 🤕.</p><p>BSW được chia ra thành những sub-layers, mỗi sub-layer cung cấp từng service nhất định cho các SWCs ở tầng ASW.</p><h3 id=21-service-layer>2.1. Service Layer<a hidden class=anchor aria-hidden=true href=#21-service-layer>#</a></h3><p><img loading=lazy src=SL.png alt="Service Layer"></p><p>Là thằng gần nhất với ASW, thật ra RTE gần hơn nhưng mình không coi RTE là hẳn một tầng 🤫. Service Layer chịu trách nhiệm chính trong việc giúp BSW cung cấp các service lên trên ASW nhờ vào API (API thì tầng nào cũng có nhé).</p><p>Ví dụ:</p><table><thead><tr><th>Loại API</th><th>Chức năng</th></tr></thead><tbody><tr><td>Communication</td><td>Giao tiếp trong network của các ECU, gửi message qua CAN, LIN, FlexRay,&mldr;</td></tr><tr><td>Diagnostic</td><td>Chuẩn đoán lỗi, dùng để đọc DTC (Diagnostic Trouble Codes).</td></tr><tr><td>Time Management</td><td>Kiểm soát các cyclic task, trên ô tô có vô số giá trị phải đọc trong lúc xe chạy như tốc độ, nhiệt độ,&mldr;</td></tr><tr><td>Memory Management</td><td>Tương tự Time Management nhưng là kiểm soát bộ nhớ dùng cho các cyclic task.</td></tr></tbody></table><p>Và còn rất nhiều loại khác như API cho Event Management, File System hoặc Security.</p><h3 id=22-ecu-abstraction-layer-eal>2.2 ECU Abstraction Layer (EAL)<a hidden class=anchor aria-hidden=true href=#22-ecu-abstraction-layer-eal>#</a></h3><p>Sub-layer này và cả sub-layer bên dưới của BSW sẽ hơi lằng nhằng bởi chúng đều mang tính &ldquo;trừu tượng&rdquo;.</p><p><img loading=lazy src=EAL.png alt="ECU Abstraction Layer"></p><p><strong>Trừu tượng</strong> ở đây cũng giống như tính chất trừu tượng bên OOP, đều mang mục đích giấu đi độ phức tạp của các implementation, giúp dev viết code một cách chuẩn hóa hơn và đỡ trầm cảm hơn.</p><p>Cụ thể, khi dev viết code ở sub-layer này, họ không phải căng mắt tìm cho ra địa chỉ của thanh ghi ADCs, ngắt, timer,&mldr; mà chỉ việc lụm API, truy cập vào tài nguyên của hardware thông qua ngoại vi, rồi config theo requirement. Mình từng thắc mắc, làm sao API có thể compatible với các hardware khác nhau ứng với mỗi con ECU khác nhau trên từng dòng xe khác nhau ? Welp, như đã nói, mọi thứ đều đã được chuẩn hóa, hardware được chuẩn hóa, software được chuẩn hóa, và API cũng vậy.</p><p><strong>Abstraction</strong> cũng là một <em>key principle</em> của AUTOSAR. Như mình đã đề cập từ đầu, có rất nhiều OEMs và Suppliers trong cuộc chơi này, nghĩa là có cả trăm loại software và hardware sắp sửa đánh nhau. Nhưng nhờ vào Abstraction, software từ một Supplier có thể dễ dàng được &ldquo;tái sử dụng&rdquo; khi switch sang hardware platform của một OEM khác và ngược lại.</p><p>Nói tóm lại, ngoài abstract giữa phần mềm với phần mềm như mọi người thường thấy, còn có cả abstract giữa phần mềm và phần cứng 🥴.</p><h3 id=32-microcontroller-abstraction-layer-mcal>3.2 Microcontroller Abstraction Layer (MCAL)<a hidden class=anchor aria-hidden=true href=#32-microcontroller-abstraction-layer-mcal>#</a></h3><p>Đây là thằng cuối cùng còn sót lại trong mớ software, nằm ngay trên hardware.</p><p><img loading=lazy src=MCAL.png alt="Microcontroller Abstraction Layer"></p><p>Thằng này thì cũng không có gì phức tạp, cơ bản là ở gần hardware nên nguyên lý khá giống với compiler. Khác ở chỗ, compiler gen ra .bin, .hex hay .obj gì đó một lần để flash xuống rồi thôi, còn MCAL cho phép high-level với low-level code nói chuyện với nhau trong real-time.</p><p>Tưởng tượng như này, <strong>ECU Abstraction Layer (EAL)</strong> chính là &ldquo;bộ não&rdquo;, trong khi <strong>Microcontroller Abstraction Layer (MCAL)</strong> đóng vai trò như một &ldquo;hệ thần kinh&rdquo;. EAL gửi đi các high-level command, còn MCAL biến các command đó thành low-level, rồi mới đi vào ECU. EAL ngồi trên đầu trên cổ thằng MCAL, giống như một bộ não, gửi tín hiệu qua hệ thần kinh để các cơ bắp hay nội tạng hoạt động theo ý muốn. Trong trường hợp này, EAL nếu muốn sử dụng tài nguyên của hardware thì phải nhờ vả MCAL.</p><h3 id=34-complex-device-drivers-cdds>3.4 Complex Device Drivers (CDDs)<a hidden class=anchor aria-hidden=true href=#34-complex-device-drivers-cdds>#</a></h3><p><img loading=lazy src=CDD.png alt="Complex Device Drivers"></p><p>Nhập gia tùy&mldr; tiện, chúng ta có một impostor ở đây. Không phải cứ nằm trong kiến trúc nào là phải mang hẳn quy tắc của kiến trúc đó. Sẽ có những trường hợp chúng ta cần tốc độ xử lý ở mức cao nhất, do đó phải bỏ qua tối đa các macro để code thẳng vào logic, tránh function call quá nhiều gây tăng instruction trong quá trình runtime. Ví dụ như việc bung túi khí, đòi hỏi tốc độ response cực kì cao.</p><p>Do đó nếu mọi người để ý, ta sẽ thấy ngoại lệ khi MCU được nối thẳng lên tầng trên qua CDD, cắt bớt layer để giảm time.<br><br><br>​</p><h2 id=4-runtime-environment-rte>4. Runtime Environment (RTE)<a hidden class=anchor aria-hidden=true href=#4-runtime-environment-rte>#</a></h2><p>Đây giồi đôi giầy, cùng quay lại với người anh em thiện lành RTE.</p><p><img loading=lazy src=RTE.png alt="Runtime Environment"></p><p>RTE thật ra là một term chung chứ không chỉ của riêng ngành nhúng, và là một environment có liên quan mật thiết đến &ldquo;system&rdquo;.</p><p>Mình chưa có cơ hội làm nhiều với system nên cũng không dám nói nhăng nói cuội. Mentor của mình đã giải thích về nó 800 lần nhưng mình vẫn không hiểu. Btw, mình từng đọc một tài liệu nói về RTE như sau:</p><blockquote><p><em>RTE là lớp phần mềm trung gian giúp hai tầng ASW và BSW giao tiếp với nhau. Mục đích của việc này là làm cho các thành phần phần mềm độc lập nhất có thể để &ldquo;ánh xạ&rdquo; tới một hệ thống điều khiển.</em></p></blockquote><p>Yep, đúng là không hiểu thật.</p><p>Cơ mà, &ldquo;<strong>ánh xạ</strong>&rdquo; là gì nhỉ ? Mình chỉ nghĩ đơn giản thế này, sở dĩ RTE tồn tại là vì AUTOSAR muốn đảm bảo ASW và BSW độc lập với nhau nhất có thể. BSW không chỉ trừu tượng hóa giữa các sub-layers bên trong mình mà còn giữa chính bản thân nó với ASW.</p><p>Giả dụ:</p><ul><li>ASW sẽ được dev 100% bởi OEM để điều khiển các function trên xe.</li><li>BSW sẽ được dev bởi Supplier để cung cấp các service cơ bản nhất cho ASW lụm về dùng.</li></ul><p>Trên thực tế con số 100% này ở tầng ASW có thể khác, OEM có thể chỉ dev 75%, 50% hoặc quẳng hết cho Supplier làm luôn tùy thuộc vào thỏa thuận hai bên. Vì lý do bảo mật công nghệ, phần trăm càng cao nghĩa là OEM càng không muốn tiết lộ công nghệ của họ 🙄 mình cho là vậy.</p><p>Dễ thấy hai khứa ASW và BSW hợp tác rất đơn giản, chỉ việc đưa và nhận, đổi lại là sự flexibility trong kiến trúc mỗi thằng. Và &ldquo;<strong>ánh xạ</strong>&rdquo;, một lần nữa, cũng là cách mà abstraction hoạt động, kết nối hai thằng này với nhau, dịch sang tiếng người nghĩa là &ldquo;<strong>mapping</strong>&rdquo;.</p><p>Nhưng map là map cái gì ? Vâng, chính là SWCs. Đơn giản, quá trình mapping chỉ định SWC nào sẽ được map đến ECU nào, chẳng hạn cụm ABS, cụm cửa sổ, cụm túi khí,&mldr;</p><p>Lớp RTE trong dự án thực tế được macro cực kì nhiều cũng bởi đặc trưng của AUTOSAR. Có đến vài chục file .c và .h bắt đầu bằng Rte như Rte.c, Rte.h, Rte_Lib.h, Rte_Type.h,&mldr;</p><p><br><br><br>​</p><h2 id=5-microcontroller-mcu>5. Microcontroller (MCU)<a hidden class=anchor aria-hidden=true href=#5-microcontroller-mcu>#</a></h2><p>Updating</p><p><br><br>​</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://du4ng.github.io/tags/software/>Software</a></li></ul></footer></article></main><footer class=footer><span>Software Engineer | <button onclick='window.open("https://www.facebook.com/me")' style=text-decoration:underline target=_blank>who is viewing</button></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>